import { useState, useEffect } from "react";
import { useAccount, useContractRead, useContractWrite, useWaitForTransactionReceipt } from "wagmi";
import erc20Abi from "../abi/erc20.json";

const USDC_ADDRESS = import.meta.env.VITE_USDC_ADDRESS as `0x${string}` | undefined;
const MM_ADDRESS = import.meta.env.VITE_MM_ADDRESS as `0x${string}` | undefined;

export default function TradeModal({
  side,
  quote,
  walletAddress,
  onClose,
}: {
  side: "buy" | "sell";
  quote: { buy_usdc: number; sell_usdc: number };
  walletAddress: string;
  onClose: () => void;
}) {
  const { chain, isConnected, address } = useAccount();
  const [amount, setAmount] = useState("");
  const [loading, setLoading] = useState(false);
  const [error, setError] = useState<string | null>(null);

  const numeric = Number(amount) || 0;
  const price = side === "buy" ? quote.buy_usdc : quote.sell_usdc;
  const usdcNeeded = side === "buy" ? Math.floor(numeric * price * 1e6) : 0;

  // Determine endpoint early (outside try)
  const endpoint = side === "buy" ? "/api/mm/buy" : "/api/mm/sell";

  if (!isConnected) return <div className="modal error">Wallet not connected</div>;
  if (!address) return <div className="modal error">No wallet address</div>;
  if (!USDC_ADDRESS || !MM_ADDRESS) return <div className="modal error">Missing USDC/MM address in .env</div>;

  if (chain?.id !== 43113) {
    return (
      <div className="modal error">
        <h3>Wrong Network</h3>
        <p>Please switch MetaMask to Avalanche Fuji Testnet (chain ID 43113)</p>
        <button className="btn" onClick={onClose}>Close</button>
      </div>
    );
  }

  const { data: allowanceData, refetch: refetchAllowance } = useContractRead({
    address: USDC_ADDRESS,
    abi: erc20Abi,
    functionName: "allowance",
    args: [address, MM_ADDRESS],
    enabled: side === "buy",
    watch: true,
  });

  const currentAllowance = allowanceData ? Number(allowanceData) : 0;
  const needsApproval = side === "buy" && currentAllowance < usdcNeeded;

  const { writeContract: approve, data: approveTx, isPending: approvePending, error: approveError } = useContractWrite();

  const { isLoading: approveLoading, isSuccess: approveSuccess } = useWaitForTransactionReceipt({
    hash: approveTx?.hash,
  });

  useEffect(() => {
    if (approveSuccess) {
      refetchAllowance();
      console.log("Approval succeeded – allowance refetched");
    }
  }, [approveSuccess, refetchAllowance]);

  async function handleApprove() {
    if (!approve) {
      setError("Wallet not ready – reconnect wallet");
      return;
    }

    if (usdcNeeded <= 0) {
      setError("Amount too small for approval");
      return;
    }

    try {
      setLoading(true);
      setError(null);

      const doubleNeeded = BigInt(usdcNeeded) * 2n;
      const minAmount = 1000000n * 1000000n;
      const approvalAmount = doubleNeeded > minAmount ? doubleNeeded : minAmount;

      approve({
        address: USDC_ADDRESS,
        abi: erc20Abi,
        functionName: "approve",
        args: [MM_ADDRESS, approvalAmount],
      });
    } catch (err: any) {
      setError(err.shortMessage || err.message || "Approval failed");
    } finally {
      setLoading(false);
    }
  }

  async function handleConfirm() {
    if (numeric <= 0) {
      setError("Amount must be greater than 0");
      return;
    }

    if (side === "buy" && needsApproval) {
      setError("Please approve USDC first");
      return;
    }

    setLoading(true);
    setError(null);

    try {
      console.log(`Sending ${side} request to ${endpoint}`);

      const res = await fetch(endpoint, {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({
          user_address: walletAddress,
          vsp_amount: Math.floor(numeric),
          expected_price_usdc: price,
        }),
      });

      if (!res.ok) {
        const errText = await res.text();
        console.error(`Backend error: ${res.status} - ${errText}`);
        throw new Error(errText || `Failed (${res.status})`);
      }

      const data = await res.json();
      alert(`${side === "buy" ? "Buy" : "Sell"} successful!`);
      onClose();
    } catch (err: any) {
      console.error("Confirm failed:", err);
      setError(err.message || "Transaction failed");
    } finally {
      setLoading(false);
    }
  }

  return (
    <div className="modal-backdrop">
      <div className="modal">
        <h3>{side === "buy" ? "Buy VSP" : "Sell VSP"}</h3>

        <div style={{ marginBottom: 12 }}>
          Connected chain: {chain?.name || "Unknown"} (ID: {chain?.id || "—"})
        </div>

        <input
          className="input"
          type="number"
          placeholder="Amount of VSP"
          value={amount}
          onChange={(e) => setAmount(e.target.value)}
          min="0"
          step="0.01"
        />

        <div style={{ marginTop: 8 }}>
          You will {side === "buy" ? "receive" : "receive"}:{" "}
          <strong>{(side === "buy" ? numeric / price : numeric * price).toFixed(4)}</strong>{" "}
          {side === "buy" ? "VSP" : "USDC"}
        </div>

        <div style={{ marginTop: 8 }}>
          Current USDC allowance: {(currentAllowance / 1e6).toFixed(2)} USDC
        </div>

        {needsApproval && side === "buy" && (
          <button
            className="btn btn-warning"
            onClick={handleApprove}
            disabled={approveLoading || approvePending || !approve}
            style={{ marginTop: 12, width: "100%" }}
          >
            {approveLoading || approvePending ? "Approving..." : "Approve USDC"}
          </button>
        )}

        {approveSuccess && <div className="success" style={{ marginTop: 12 }}>USDC approved!</div>}
        {approveError && <div className="error" style={{ marginTop: 12 }}>
          {approveError.shortMessage || approveError.message || "Approval error"}
        </div>}

        {error && <div className="error" style={{ marginTop: 12 }}>{error}</div>}

        <div className="row" style={{ marginTop: 20, justifyContent: "flex-end", gap: 12 }}>
          <button className="btn" onClick={onClose} disabled={loading}>
            Cancel
          </button>
          <button
            className="btn btn-primary"
            onClick={handleConfirm}
            disabled={loading || (side === "buy" && needsApproval) || !numeric}
          >
            {loading ? "Processing..." : "Confirm"}
          </button>
        </div>
      </div>
    </div>
  );
}
